<html>

<head>
<style type="text/css">
			.box25 {
				float: left;
				width: 25%;
                                height:100%;
                	}
                        .box75 {
                                float: left;
                                width: 75%;
                                height:100%;
                        }
			
			.container {
				clear: both;
			}

                        canvas {
                            margin: 0px;
                            border: 0px;
                            width: 100%;
                            height:100%;
                        }
}
		</style>
<title>MRIS Viewer</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link type="text/css" href="../jquery/css/ui-darkness/jquery-ui-1.8.7.custom.css" rel="stylesheet" />
<script type="text/javascript" src="../jquery/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="../jquery/js/jquery-ui-1.8.7.custom.min.js"></script>

<script type="text/javascript" src="../common/sylvester.js"></script>
<script type="text/javascript" src="../common/glUtils.js"></script>
<script type="text/javascript" src="../common/binaryParseUtils.js"></script>
<script type="text/javascript" src="../common/mrisLoader.js"></script>
<script type="text/javascript" src="../common/crvLoader.js"></script>
<script type="text/javascript" src="../common/trkLoader.js"></script>
<script type="text/javascript" src="../common/brainSurface.js"></script>
<script type="text/javascript" src="../common/tractography.js"></script>

<script type="text/javascript">

       
  var gl;
  function initGL(canvas)
  {
    try {
      gl = canvas.getContext("experimental-webgl");
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    } catch(e) {
    }
    if (!gl) {
      alert("Could not initialise WebGL.  Please make sure your browser supports WebGL.");
    }
  }


  
  var mvMatrix;
  var mvMatrixStack = [];

  function mvPushMatrix(m) {
    if (m) {
      mvMatrixStack.push(m.dup());
      mvMatrix = m.dup();
    } else {
      mvMatrixStack.push(mvMatrix.dup());
    }
  }

  function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
      throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
    return mvMatrix;
  }


  function loadIdentity() {
    mvMatrix = Matrix.I(4);
  }


  function multMatrix(m) {
    mvMatrix = mvMatrix.x(m);
  }


  function mvTranslate(v) {
    var m = Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4();
    multMatrix(m);
  }

  function createRotationMatrix(angle, v) {
    var arad = angle * Math.PI / 180.0;
    return Matrix.Rotation(arad, $V([v[0], v[1], v[2]])).ensure4x4();
  }

  function mvRotate(ang, v) {
    var arad = ang * Math.PI / 180.0;
    var m = Matrix.Rotation(arad, $V([v[0], v[1], v[2]])).ensure4x4();
    multMatrix(m);
  }

function mvScale(sx, sy, sz)
{
    mvMatrix.elements[0][0] *= sx;
    mvMatrix.elements[0][1] *= sx;
    mvMatrix.elements[0][2] *= sx;
    mvMatrix.elements[0][3] *= sx;

    mvMatrix.elements[1][0] *= sy;
    mvMatrix.elements[1][1] *= sy;
    mvMatrix.elements[1][2] *= sy;
    mvMatrix.elements[1][3] *= sy;

    mvMatrix.elements[2][0] *= sz;
    mvMatrix.elements[2][1] *= sz;
    mvMatrix.elements[2][2] *= sz;
    mvMatrix.elements[2][3] *= sz;
}

  var pMatrix;
  function perspective(fovy, aspect, znear, zfar) {
    pMatrix = makePerspective(fovy, aspect, znear, zfar);
  }


  var z = -4.0;
  var currentlyPressedKeys = Object();

  function handleKeyDown(event) {
    currentlyPressedKeys[event.keyCode] = true;

    // Handle key presses here
  }


  function handleKeyUp(event) {
    currentlyPressedKeys[event.keyCode] = false;
  }


  function handleKeys() {
    if (currentlyPressedKeys[33]) {
      // Page Up
      z -= 0.05;
    }
    if (currentlyPressedKeys[34]) {
      // Page Down
      z += 0.05;
    }
    if (currentlyPressedKeys[37]) {
      // Left cursor key
      ySpeed -= 1;
    }
    if (currentlyPressedKeys[39]) {
      // Right cursor key
      ySpeed += 1;
    }
    if (currentlyPressedKeys[38]) {
      // Up cursor key
      xSpeed -= 1;
    }
    if (currentlyPressedKeys[40]) {
      // Down cursor key
      xSpeed += 1;
    }
  }


  var mouseDown = false;
  var lastMouseX = null;
  var lastMouseY = null;

  var brainRotationMatrix = Matrix.I(4);

  function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
  }


  function handleMouseUp(event) {
    mouseDown = false;
  }


  function handleMouseMove(event) {
    if (!mouseDown) {
      return;
    }
    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX
    var newRotationMatrix = createRotationMatrix(deltaX / 10, [0, 1, 0]);

    var deltaY = newY - lastMouseY;
    newRotationMatrix = newRotationMatrix.x(createRotationMatrix(deltaY / 10, [1, 0, 0]));

    brainRotationMatrix = newRotationMatrix.x(brainRotationMatrix);

    lastMouseX = newX
    lastMouseY = newY;
  }

  function handleMouseWheel(e) {
    // From SpiderGL
    var delta = 0;
    if (!e) /* For IE. */ {
            e = window.event;
    }
    if (e.wheelDelta) /* IE/Opera. */ {
            delta = e.wheelDelta / 120;
            /* In Opera 9, delta differs in sign as compared to IE.
             */
            if (window.opera) {
                    delta = -delta;
            }
    }
    else if (e.detail) /** Mozilla case. */ {
            /** In Mozilla, sign of delta is different than in IE.
             * Also, delta is multiple of 3.
             */
            delta = -e.detail / 3;
    }
    /* If delta is nonzero, handle it.
     * Basically, delta is now positive if wheel was scrolled up,
     * and negative, if wheel was scrolled down.
     */
    if (delta) {
        z += (delta / 2);
    }
  }

  var gBrainSurfaces = new Array(2);
  var gTracks = new Tractography();
  
  function loadMRIS(surface, surfaceFile, callback)
  {
      mrisURL = location.search.substring(1)
      console.log('URL: ' + mrisURL + '/' + surfaceFile);
      surface.loadSurface(mrisURL + '/' + surfaceFile, callback);
  }



  function drawScene() {

    var canvas = document.getElementById("webgl-canvas");
    canvas.width = canvas.clientWidth;//window.innerWidth;
    canvas.height = canvas.clientHeight;//window.innerHeight;
    gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    
    perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
    loadIdentity();
 


    var scale = 0.01513;

    mvScale(scale, scale, scale);
    mvTranslate([0.0, 0.0, z / scale]);

    mvPushMatrix();
    multMatrix(brainRotationMatrix);
    mvRotate(-90.0, [1, 0, 0]);
    mvRotate(180.0, [0, 0, 1]);


       //@TEMP
    //var vox_to_ras = gTracks.trkFile.trkHeader.vox_to_ras;
    var vox_to_ras = $M([[-1.7180329561233521, 0.047996673732995987, 0.016228966414928436, 105.16133117675781], [-0.047932315617799759, -1.7180588245391846, 0.011287901550531387, 125.35425567626953], [0.012920046225190163, 0.0084614064544439316, 2.1999111175537109, -39.09844970703125], [0.0, 0.0, 0.0, 1.0]]);

    multMatrix(vox_to_ras);
    //@TEMP

    
    // Get a common scale and curvature for both hemispheres
    /*
    var scale = gBrainSurfaces[0].curScale[0];
    if (gBrainSurfaces[1].curScale[0] > scale)
        scale = gBrainSurfaces[1].curScale[0];
        */

    if (gShowTracks && gTracks.vertexPositionBuffer != null)
    {
        gTracks.drawTracks(pMatrix, mvMatrix, 1.0);
    }
    mvPopMatrix();
    mvPushMatrix();
    loadIdentity();
    //@TEMP
/*    var regMatrix = Matrix.I(4);

    regMatrix.setElements([[0.99973,  -0.0227872,  -0.00207516,  15.4285],
                                  [0.0228081,  0.999683,  0.0106906,  -25.0657],
                                  [0.00183089,  -0.0107352,  0.999941,  -77.8571],
                                  [0,  0,  0,  1]]);
    multMatrix(regMatrix);
    mvTranslate([-15.4285 * scale, 25.0657 * scale, 77.8571 * scale]);
*/
    mvScale(scale, scale, scale);
    //mvTranslate([15.4285 / scale, -25.0657 / scale, -77.8571 / scale])
    mvTranslate([0.0, 0.0, z / scale]);

    //mvTranslate([-15.4285 * scale, 25.0257 * scale, 77.8571 * scale]);
    //mvTranslate([-15.4285 / scale, 25.0657 / scale, 77.8571 / scale]);
        

    multMatrix(brainRotationMatrix);

    
    mvRotate(-90.0, [1, 0, 0]);
    // Do not rotate about z because the coordinates need to be y-inverted
    // from the track
    //mvRotate(180.0, [0, 0, 1]);


    gl.frontFace( gl.CCW );
    gl.enable( gl.CULL_FACE );
    gl.enable( gl.BLEND );
    gl.blendFunc ( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    if (gHemisphere[0] && gBrainSurfaces[0].vertexPositionBuffer != null)
    {
        gBrainSurfaces[0].drawSurface(pMatrix, mvMatrix, 1.0);
    }
    if (gHemisphere[1] && gBrainSurfaces[1].vertexPositionBuffer != null)
    {
        gBrainSurfaces[1].drawSurface(pMatrix, mvMatrix, 1.0);
    }

    gl.disable( gl.BLEND);
        
    mvPopMatrix();

  }

  var lastTime = 0;
  function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
      var elapsed = timeNow - lastTime;

      // Animate here
    }
    lastTime = timeNow;
  }

  function tick() {
    
    handleKeys();
    drawScene();
    animate();

    $("#loading").empty().html("");

  }


var gHemisphere = [ 1, 1 ];
var gHemisphereNames = [ 'lh', 'rh' ];
var gSurface = 'smoothwm'
var gCurvature = undefined;
var gShowTracks = false;

  function webGLStart() {
    var canvas = document.getElementById("webgl-canvas");
    initGL(canvas);

    $("#loading").empty().html('Loading, please wait...');
    gBrainSurfaces[0] = new BrainSurface();
    gBrainSurfaces[1] = new BrainSurface();    
    loadMRIS( gBrainSurfaces[0], gHemisphereNames[0] + '.' + gSurface, handleLoadedSurface );
    loadMRIS( gBrainSurfaces[1], gHemisphereNames[1] + '.' + gSurface, handleLoadedSurface);
    gTracks.loadTracks("/chb/osx1927/1/users/dicom/postproc/projects/ginsburg/demo/2034610-20090608_013Y-20100510-1273520211347135943-demo/tract_meta-stage-2-dcm2trk.bash/final-trackvis/2034610-20090608_013Y-20100510-1273520211347135943-demo.trk");

    gl.clearColor(0.0, 0.0, 0.0, 0.0);

    gl.clearDepth(1.0);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;
    canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;
    document.onmousewheel = handleMouseWheel;

    setInterval(tick, 15);
  }


function surfaceChanged()
{
    gSurface = $('#surface_select :selected').text();

    loadMRIS( gBrainSurfaces[0], gHemisphereNames[0] + '.' + gSurface );
    loadMRIS( gBrainSurfaces[1], gHemisphereNames[1] + '.' + gSurface );
}

function toggleHemispheres()
{
    gHemisphere[0] = $('#lh_hemisphere:checked').val();
    gHemisphere[1] = $('#rh_hemisphere:checked').val();
}

function toggleTracks()
{
    gShowTracks = $('#tractography:checked').val();
}

function curvatureChanged()
{
    gCurvature = $('#curvature_select :selected').text();

    if (gCurvature == 'None')
    {
        $( "#amount" ).val( ' ' );
        gBrainSurfaces[0].drawCurvature = 0;
        gBrainSurfaces[1].drawCurvature = 0;
    }
    else
    {
        for (var hemi = 0; hemi < 2; hemi++)
        {
            var crvFile = gHemisphereNames[hemi] + '.' + gSurface + '.' + gCurvature + '.crv';
            var crvURL = location.search.substring(1)
            console.log('URL: ' + crvURL + '/' + crvFile);
            gBrainSurfaces[hemi].loadCurvature(crvURL + '/' + crvFile, handleLoadedCurvature);
        }        
    }

}

function handleLoadedSurface(brainSurface)
{

    if (gBrainSurfaces[0].vertexPositionBuffer != null &&
        gBrainSurfaces[1].vertexPositionBuffer != null)
    {
        curvatureChanged();
    }
}

function handleLoadedCurvature(brainSurface)
{
    if (gBrainSurfaces[0].vertexCurvatureBuffer != null &&
        gBrainSurfaces[1].vertexCurvatureBuffer != null)
    {
        var values = $( "#slider-range" ).slider( "option", "values" );
        var minSlider = 0;
        var maxSlider = 1000;

        var curSliderMin = (values[0] - minSlider) / (maxSlider - minSlider);
        var curSliderMax = (values[1] - minSlider) / (maxSlider - minSlider);

        // Get the min/max from both hemispheres
        var minCurv = gBrainSurfaces[0].crvFile.minCurv[1];
        var maxCurv = gBrainSurfaces[0].crvFile.maxCurv[1];
        if (gBrainSurfaces[1].crvFile.minCurv[1] < minCurv)
            minCurv = gBrainSurfaces[1].crvFile.minCurv[1];
        if (gBrainSurfaces[1].crvFile.maxCurv[1] < maxCurv)
            maxCurv = gBrainSurfaces[1].crvFile.maxCurv[1];

        for (var hemi = 0; hemi < 2; hemi++)
        {
            gBrainSurfaces[hemi].curCurvMin[0] = (1.0 - curSliderMin) * minCurv + curSliderMin * maxCurv;
            gBrainSurfaces[hemi].curCurvMax[0] = (1.0 - curSliderMax) * minCurv + curSliderMax * maxCurv;
        }
    }
}

function handleOpacitySlider(event, ui)
{
    var minSlider = 0;
    var maxSlider = 100;
    var opacity = (ui.value - minSlider) / (maxSlider - minSlider)

    gBrainSurfaces[0].setOpacity(opacity);
    gBrainSurfaces[1].setOpacity(opacity);
}

function handleTrackLengthSlider(event, ui)
{
    //var minSlider = 0;
    //var maxSlider = 100;
    //var minTrackLength = (ui.value - minSlider) / (maxSlider - minSlider)

    gTracks.setMinTrackLength(ui.value);
}

function handleCurvatureSlider(event, ui)
{
    var minSlider = 0;
    var maxSlider = 1000;

    var curSliderMin = (ui.values[0] - minSlider) / (maxSlider - minSlider);
    var curSliderMax = (ui.values[1] - minSlider) / (maxSlider - minSlider);

    // Get the min/max from both hemispheres
    var minCurv = gBrainSurfaces[0].crvFile.minCurv[1];
    var maxCurv = gBrainSurfaces[0].crvFile.maxCurv[1];
    if (gBrainSurfaces[1].crvFile.minCurv[1] < minCurv)
        minCurv = gBrainSurfaces[1].crvFile.minCurv[1];
    if (gBrainSurfaces[1].crvFile.maxCurv[1] < maxCurv)
        maxCurv = gBrainSurfaces[1].crvFile.maxCurv[1];

    for (var hemi = 0; hemi < 2; hemi++)
    {
        gBrainSurfaces[hemi].curCurvMin[0] = (1.0 - curSliderMin) * minCurv + curSliderMin * maxCurv;
        gBrainSurfaces[hemi].curCurvMax[0] = (1.0 - curSliderMax) * minCurv + curSliderMax * maxCurv;
    }
}

$(function() {
		$( "#controls" ).accordion({
			fillSpace: true,
                        autoHeight: false
		});
                $( "#viewer" ).accordion({
			fillSpace: true,
                        autoHeight: false
		});

                $( "#slider-range" ).slider({
			range: true,
			min: 0,
			max: 1000,
			values: [ 530, 665 ],
			slide: handleCurvatureSlider
		});
                $( "#slider-opacity" ).slider({
                        range: false,
			min: 0,
			max: 100,
			value: 100,
			slide: handleOpacitySlider
		});
                $( "#slider-tracklength" ).slider({
                        range: false,
			min: 0,
			max: 100,
			value: 15,
			slide: handleTrackLengthSlider
		});                
	});

</script>


</head>


<body onload="webGLStart();">

    <div class="container">
        <div class="box25">
                <div id="controls" align>
                    <h5><a href="#">Viewer Options</a></h5>
                    <div>
                        <form>
                            Surface:
                                <SELECT id="surface_select" onchange="surfaceChanged()">
                                    <option value="smoothwm">White Matter</option>
                                    <option value="pial">Pial</option>
                                </SELECT>                            
                        </form>
                        Surface Opacity:

                                <div id="slider-opacity"></div>
                            <BR/>
                        <form id="hemisphere_select">
                            Display:
                            <BR/>
                            <input type="checkbox" id="lh_hemisphere" checked="checked" onclick="toggleHemispheres()" value="lh" />Left Hemisphere
                            <BR/>
                            <input type="checkbox" id="rh_hemisphere" checked="checked" onclick="toggleHemispheres()" value="rh" />Right Hemisphere
                            <BR/>
                            <input type="checkbox" id="tractography" onclick="toggleTracks()"/>Tractography

                        </form>
                        <form>
                            Curvature:
                                <SELECT id="curvature_select" onchange="curvatureChanged()">
                                    <option value="None">None</option>
                                    <option value="BE">BE</option>
                                    <option value="C">C</option>
                                    <option value="FI">FI</option>
                                    <option selected value="H">H</option>
                                    <option value="K">K</option>
                                    <option value="K1">K1</option>
                                    <option value="K2">K2</option>
                                    <option value="S">S</option>
                                </SELECT>
                                <BR/>
                        </form>
                        Curvature display range:
                        <div id="slider-range"></div>
                        Track Length:
                            <div id="slider-tracklength"></div>
                    </div>
                </div>
        </div>
        <div class="box75">
                <div id="viewer">
                    <h5><a href="#">Surface Viewer</a></h5>
                    <div>
                        <div id="loading"></div>
                
                        <canvas id="webgl-canvas" ></canvas>
                    </div>
                </div>
        </div>
    </div>                 
</body>

</html>
